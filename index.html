<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flat Earth Model v6 - –†–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ–µ –æ—Å–≤–µ—â–µ–Ω–∏–µ</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; background: #000; }
.container { display: flex; height: 100vh; }
#canvas { flex: 1; display: block; }
.panel { width: 420px; background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%); color: #e0e0e0; padding: 20px; overflow-y: auto; box-shadow: -5px 0 15px rgba(0,0,0,0.3); }
.panel h1 { font-size: 24px; margin-bottom: 20px; color: #4ecdc4; text-align: center; }
.section { margin-bottom: 25px; background: rgba(255,255,255,0.05); padding: 15px; border-radius: 10px; border: 1px solid rgba(78, 205, 196, 0.2); }
.section-title { font-size: 16px; font-weight: bold; margin-bottom: 12px; color: #4ecdc4; }
.control-group { margin-bottom: 15px; }
.control-group label { display: block; margin-bottom: 5px; font-size: 13px; color: #b0b0b0; }
.control-group input, .control-group select { width: 100%; padding: 8px; background: rgba(0,0,0,0.3); border: 1px solid rgba(78, 205, 196, 0.3); border-radius: 5px; color: #e0e0e0; font-size: 14px; }
.time-controls { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
.btn { width: 100%; padding: 10px; background: linear-gradient(135deg, #4ecdc4 0%, #3aa99f 100%); border: none; border-radius: 5px; color: white; font-weight: bold; cursor: pointer; margin-top: 10px; font-size: 14px; }
.btn:hover { box-shadow: 0 5px 15px rgba(78, 205, 196, 0.4); }
.btn-secondary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
.btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
.speed-control { display: flex; align-items: center; gap: 10px; margin-top: 10px; }
.speed-control input[type="range"] { flex: 1; }
.compact-datetime { display: grid; grid-template-columns: repeat(5, 1fr) auto; gap: 5px; align-items: end; }
.compact-datetime input { width: 100%; padding: 5px; font-size: 12px; text-align: center; }
.compact-datetime label { font-size: 10px; text-align: center; display: block; margin-bottom: 2px; color: #888; }
.compact-datetime .apply-btn { padding: 5px 10px; margin-top: 15px; }
.speed-label { min-width: 60px; text-align: center; font-weight: bold; color: #4ecdc4; }
#currentTime { text-align: center; padding: 10px; background: rgba(78, 205, 196, 0.1); border-radius: 5px; margin-bottom: 15px; font-size: 18px; font-weight: bold; color: #4ecdc4; }
#celestialInfo { font-size: 12px; color: #aaa; line-height: 1.6; }
#eventList { max-height: 250px; overflow-y: auto; }
#eventList > div { background: rgba(0,0,0,0.2); padding: 10px; border-radius: 5px; margin-bottom: 10px; font-size: 13px; }
#eventList button { margin-top: 8px; padding: 5px 10px; background: #ff6b6b; border: none; border-radius: 3px; color: white; cursor: pointer; font-size: 12px; }
hr { border: none; height: 1px; background: rgba(78, 205, 196, 0.2); margin: 10px 0; }
</style>
</head>
<body>
<div class="container">
<canvas id="canvas"></canvas>
<div class="panel">
<h1>üåç Flat Earth Model v6</h1>
<div class="section">
<div class="section-title">‚è∞ –¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è</div>
<div id="currentTime">--:--:--</div>
<div id="celestialInfo">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
<div class="btn-group">
<button class="btn" id="playBtn" onclick="togglePlay()">‚ñ∂ –ü—É—Å–∫</button>
<button class="btn btn-secondary" onclick="resetTime()">üîÑ –°–±—Ä–æ—Å</button>
</div>
<div class="speed-control">
<label style="min-width: 90px; color: #b0b0b0;">–°–∫–æ—Ä–æ—Å—Ç—å:</label>
<input type="range" id="speedSlider" min="1" max="10000" value="60" step="1">
<span class="speed-label" id="speedLabel">60x</span>
</div>
  <button class="btn btn-secondary" onclick="toggleGrid()" style="margin-top: 5px;">üìç –°–µ—Ç–∫–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç</button>
</div>
<div class="section">
<div class="section-title">üìÖ –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤—Ä–µ–º—è</div>
<div class="control-group">
<label>–ì–æ–¥</label>
<input type="number" id="year" value="2025" min="2000" max="2100">
</div>
<div class="compact-datetime">
<div class="control-group"><label>–ú–µ—Å—è—Ü</label><input type="number" id="month" value="11" min="1" max="12"></div>
<div class="control-group"><label>–î–µ–Ω—å</label><input type="number" id="day" value="25" min="1" max="31"></div>
</div>
<div class="compact-datetime">
<div class="control-group"><label>–ß–∞—Å</label><input type="number" id="hour" value="12" min="0" max="23"></div>
<div class="control-group"><label>–ú–∏–Ω—É—Ç—ã</label><input type="number" id="minute" value="0" min="0" max="59"></div>
</div>
<button class="btn" onclick="updateTimeFromInputs()">–ü—Ä–∏–º–µ–Ω–∏—Ç—å</button>
</div>
<div class="section">
<div class="section-title">üåë –°–æ–±—ã—Ç–∏—è –∑–∞—Ç–º–µ–Ω–∏–π</div>
<div id="eventList">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
</div>
</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script type="module">
import SurfaceLayer from './layers/layer0-surface.js';
import GridLayer from './layers/layer1-grid.js';
  
let scene, camera, renderer, controls, surfaceLayer, gridLayer;
let timeState = { year: 2025, month: 11, day: 25, hour: 12, minute: 0, second: 0 };
let isPlaying = false;
let timeSpeed = 60;
let lastFrameTime = Date.now();

const EARTH_RADIUS = 20000;
const SUN_HEIGHT = 5000;
const MOON_HEIGHT = 4000;
const SUN_ORBIT_RADIUS_MIN = EARTH_RADIUS * 0.25;
const SUN_ORBIT_RADIUS_MAX = EARTH_RADIUS * 0.45;
const MOON_ORBIT_RADIUS = EARTH_RADIUS * 0.35;

function getDayOfYear(year, month, day) {
const date = new Date(year, month - 1, day);
const start = new Date(year, 0, 1);
return Math.floor((date - start) / 86400000) + 1;
}

function isLeapYear(year) {
return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
}

function getSolarDeclination(dayOfYear, year) {
const daysInYear = isLeapYear(year) ? 366 : 365;
const maxDeclination = 23.44 * Math.PI / 180;
const summerSolstice = 172;
const angle = 2 * Math.PI * (dayOfYear - summerSolstice) / daysInYear;
return maxDeclination * Math.cos(angle);
}

function getSunOrbitRadius(declination) {
const normalizedDeclination = declination / (23.44 * Math.PI / 180);
const midRadius = (SUN_ORBIT_RADIUS_MIN + SUN_ORBIT_RADIUS_MAX) / 2;
const radiusRange = (SUN_ORBIT_RADIUS_MAX - SUN_ORBIT_RADIUS_MIN) / 2;
return midRadius - normalizedDeclination * radiusRange;
}

function getMoonPhase(year, month, day) {
const synodicMonth = 29.53;
const knownNewMoon = new Date(2000, 0, 6);
const currentDate = new Date(year, month - 1, day);
const daysSinceNewMoon = (currentDate - knownNewMoon) / 86400000;
const phase = (daysSinceNewMoon % synodicMonth) / synodicMonth;
return phase < 0 ? phase + 1 : phase;
}

function getMoonIntensity(phase) {
const I_max = 0.25;
return I_max * Math.pow(Math.sin(Math.PI * phase), 2);
}

function calculateCelestialPositions(time) {
const dayOfYear = getDayOfYear(time.year, time.month, time.day);
const declination = getSolarDeclination(dayOfYear, time.year);
const sunOrbitRadius = getSunOrbitRadius(declination);

const hourFraction = (time.hour + time.minute / 60 + time.second / 3600) / 24;
const hourAngle = -hourFraction * 2 * Math.PI;

const sunX = sunOrbitRadius * Math.cos(hourAngle);
const sunZ = sunOrbitRadius * Math.sin(hourAngle);
const sunY = SUN_HEIGHT;

const moonPhase = getMoonPhase(time.year, time.month, time.day);
const moonPhaseAngle = moonPhase * 2 * Math.PI;
const moonAngle = hourAngle + moonPhaseAngle;
const moonX = MOON_ORBIT_RADIUS * Math.cos(moonAngle);
const moonZ = MOON_ORBIT_RADIUS * Math.sin(moonAngle);
const moonY = MOON_HEIGHT;

return {
sun: { x: sunX, y: sunY, z: sunZ, orbitRadius: sunOrbitRadius, declination: declination * 180 / Math.PI },
moon: { x: moonX, y: moonY, z: moonZ, phase: moonPhase, phaseName: getMoonPhaseName(moonPhase), intensity: getMoonIntensity(moonPhase) },
dayOfYear: dayOfYear
};
}

function getMoonPhaseName(phase) {
if (phase < 0.03 || phase > 0.97) return '–ù–æ–≤–æ–ª—É–Ω–∏–µ';
if (phase < 0.22) return '–ú–æ–ª–æ–¥–∞—è –ª—É–Ω–∞';
if (phase < 0.28) return '–ü–µ—Ä–≤–∞—è —á–µ—Ç–≤–µ—Ä—Ç—å';
if (phase < 0.47) return '–ü—Ä–∏–±—ã–≤–∞—é—â–∞—è';
if (phase < 0.53) return '–ü–æ–ª–Ω–æ–ª—É–Ω–∏–µ';
if (phase < 0.72) return '–£–±—ã–≤–∞—é—â–∞—è';
if (phase < 0.78) return '–ü–æ—Å–ª–µ–¥–Ω—è—è —á–µ—Ç–≤–µ—Ä—Ç—å';
return '–°—Ç–∞—Ä–∞—è –ª—É–Ω–∞';
}

async function loadEvents() {
try {
const resp = await fetch('./assets/events/eclipse_events.json');
const events = await resp.json();
const eventList = document.getElementById('eventList');
eventList.innerHTML = events.map(ev => `<div><b>${ev.event === 'solar_eclipse' ? '‚òÄÔ∏è –°–æ–ª–Ω–µ—á–Ω–æ–µ –∑–∞—Ç–º–µ–Ω–∏–µ' : 'üåô –õ—É–Ω–Ω–æ–µ –∑–∞—Ç–º–µ–Ω–∏–µ'}</b><br>${ev.date.slice(0,10)}<br>${ev.description}<br><button onclick="window.setEventTime('${ev.date}',${ev.longitude},${ev.latitude})">–ü–æ–∫–∞–∑–∞—Ç—å</button></div>`).join('<hr>');
} catch (error) {
document.getElementById('eventList').innerHTML = '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏';
}
}

function updateTimeDisplay() {
const h = String(timeState.hour).padStart(2, '0');
const m = String(timeState.minute).padStart(2, '0');
const s = String(Math.floor(timeState.second)).padStart(2, '0');
document.getElementById('currentTime').textContent = `${timeState.year}-${String(timeState.month).padStart(2, '0')}-${String(timeState.day).padStart(2, '0')} ${h}:${m}:${s}`;
}

function updateCelestialInfo(positions) {
document.getElementById('celestialInfo').innerHTML = `<b>‚òÄÔ∏è –°–æ–ª–Ω—Ü–µ:</b> –æ—Ä–±–∏—Ç–∞ ${Math.round(positions.sun.orbitRadius)}–º, —Å–∫–ª–æ–Ω–µ–Ω–∏–µ ${positions.sun.declination.toFixed(1)}¬∞<br><b>üåô –õ—É–Ω–∞:</b> ${positions.moon.phaseName} (${Math.round(positions.moon.phase * 100)}%)<br><b>üí° –ò–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å –õ—É–Ω—ã:</b> ${positions.moon.intensity.toFixed(4)} –ª—é–∫—Å<br><b>üóì –î–µ–Ω—å –≥–æ–¥–∞:</b> ${positions.dayOfYear}`;
}

window.setEventTime = (date, lon, lat) => {
const d = new Date(date);
timeState = { year: d.getUTCFullYear(), month: d.getUTCMonth() + 1, day: d.getUTCDate(), hour: d.getUTCHours(), minute: d.getUTCMinutes(), second: 0 };
document.getElementById('year').value = timeState.year;
document.getElementById('month').value = timeState.month;
document.getElementById('day').value = timeState.day;
document.getElementById('hour').value = timeState.hour;
document.getElementById('minute').value = timeState.minute;
updateModel();
updateTimeDisplay();
if (surfaceLayer) surfaceLayer.showEclipseMarker(lon, lat);
};

window.updateTimeFromInputs = () => {
timeState = {
year: parseInt(document.getElementById('year').value),
month: parseInt(document.getElementById('month').value),
day: parseInt(document.getElementById('day').value),
hour: parseInt(document.getElementById('hour').value),
minute: parseInt(document.getElementById('minute').value),
second: 0
};
updateModel();
updateTimeDisplay();
};

window.togglePlay = () => {
isPlaying = !isPlaying;
document.getElementById('playBtn').textContent = isPlaying ? '‚è∏ –ü–∞—É–∑–∞' : '‚ñ∂ –ü—É—Å–∫';
};

window.resetTime = () => {
timeState = { year: 2025, month: 11, day: 25, hour: 12, minute: 0, second: 0 };
document.getElementById('year').value = 2025;
document.getElementById('month').value = 11;
document.getElementById('day').value = 25;
document.getElementById('hour').value = 12;
document.getElementById('minute').value = 0;
updateModel();
updateTimeDisplay();
};

function initScene() {
scene = new THREE.Scene();
scene.background = new THREE.Color(0x000510);
scene.fog = new THREE.Fog(0x000510, 100000, 300000);

camera = new THREE.PerspectiveCamera(60, (window.innerWidth - 420) / window.innerHeight, 1000, 500000);
camera.position.set(0, 50000, 50000);
camera.lookAt(0, 0, 0);

const canvas = document.getElementById('canvas');
renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setSize(window.innerWidth - 420, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);

controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.minDistance = 15000;
controls.maxDistance = 150000;

scene.add(new THREE.AmbientLight(0x404060, 0.2));

surfaceLayer = new SurfaceLayer(scene, { earthRadius: EARTH_RADIUS });
gridLayer = new GridLayer(scene, { earthRadius: EARTH_RADIUS });
  
updateModel();
updateTimeDisplay();
loadEvents();
animate();
}

function updateModel() {
if (surfaceLayer) {
const positions = calculateCelestialPositions(timeState);
surfaceLayer.updateLighting(positions.sun, positions.moon, positions.sun.declination);
updateCelestialInfo(positions);
}
}

function animate() {
requestAnimationFrame(animate);

if (isPlaying) {
const now = Date.now();
const deltaTime = (now - lastFrameTime) / 1000;
lastFrameTime = now;

timeState.second += deltaTime * timeSpeed;

while (timeState.second >= 60) {
timeState.second -= 60;
timeState.minute++;
if (timeState.minute >= 60) {
timeState.minute = 0;
timeState.hour++;
if (timeState.hour >= 24) {
timeState.hour = 0;
timeState.day++;
const daysInMonth = new Date(timeState.year, timeState.month, 0).getDate();
if (timeState.day > daysInMonth) {
timeState.day = 1;
timeState.month++;
if (timeState.month > 12) {
timeState.month = 1;
timeState.year++;
}
}
}
}
}

updateModel();
updateTimeDisplay();
} else {
lastFrameTime = Date.now();
}

controls.update();
renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
camera.aspect = (window.innerWidth - 420) / window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth - 420, window.innerHeight);
});

document.getElementById('speedSlider').addEventListener('input', (e) => {
timeSpeed = parseInt(e.target.value);
document.getElementById('speedLabel').textContent = timeSpeed + 'x';
});

window.addEventListener('DOMContentLoaded', initScene);
</script>
</body>
</html>
